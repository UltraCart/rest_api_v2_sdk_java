/*
 * UltraCart Rest API V2
 * UltraCart REST API Version 2
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@ultracart.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ultracart.admin.v2.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.ultracart.admin.v2.util.JSON;

/**
 * ResultSet
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-15T16:57:28.765-05:00[America/Indianapolis]")
public class ResultSet {
  public static final String SERIALIZED_NAME_COUNT = "count";
  @SerializedName(SERIALIZED_NAME_COUNT)
  private Integer count;

  public static final String SERIALIZED_NAME_LIMIT = "limit";
  @SerializedName(SERIALIZED_NAME_LIMIT)
  private Integer limit;

  public static final String SERIALIZED_NAME_MORE = "more";
  @SerializedName(SERIALIZED_NAME_MORE)
  private Boolean more;

  public static final String SERIALIZED_NAME_NEXT_OFFSET = "next_offset";
  @SerializedName(SERIALIZED_NAME_NEXT_OFFSET)
  private Integer nextOffset;

  public static final String SERIALIZED_NAME_OFFSET = "offset";
  @SerializedName(SERIALIZED_NAME_OFFSET)
  private Integer offset;

  public static final String SERIALIZED_NAME_TOTAL_RECORDS = "total_records";
  @SerializedName(SERIALIZED_NAME_TOTAL_RECORDS)
  private Integer totalRecords;

  public ResultSet() { 
  }

  public ResultSet count(Integer count) {
    
    this.count = count;
    return this;
  }

   /**
   * Number of results in this set
   * @return count
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Number of results in this set")

  public Integer getCount() {
    return count;
  }


  public void setCount(Integer count) {
    this.count = count;
  }


  public ResultSet limit(Integer limit) {
    
    this.limit = limit;
    return this;
  }

   /**
   * Maximum number of results that can be returned in a set
   * @return limit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Maximum number of results that can be returned in a set")

  public Integer getLimit() {
    return limit;
  }


  public void setLimit(Integer limit) {
    this.limit = limit;
  }


  public ResultSet more(Boolean more) {
    
    this.more = more;
    return this;
  }

   /**
   * True if there are more results to query
   * @return more
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "True if there are more results to query")

  public Boolean getMore() {
    return more;
  }


  public void setMore(Boolean more) {
    this.more = more;
  }


  public ResultSet nextOffset(Integer nextOffset) {
    
    this.nextOffset = nextOffset;
    return this;
  }

   /**
   * The next offset that you should query to retrieve more results
   * @return nextOffset
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The next offset that you should query to retrieve more results")

  public Integer getNextOffset() {
    return nextOffset;
  }


  public void setNextOffset(Integer nextOffset) {
    this.nextOffset = nextOffset;
  }


  public ResultSet offset(Integer offset) {
    
    this.offset = offset;
    return this;
  }

   /**
   * Offset of this result set (zero based)
   * @return offset
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Offset of this result set (zero based)")

  public Integer getOffset() {
    return offset;
  }


  public void setOffset(Integer offset) {
    this.offset = offset;
  }


  public ResultSet totalRecords(Integer totalRecords) {
    
    this.totalRecords = totalRecords;
    return this;
  }

   /**
   * The total number of records in the result set.  May be null if the number is not known and the client should continue iterating as long as more is true.
   * @return totalRecords
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The total number of records in the result set.  May be null if the number is not known and the client should continue iterating as long as more is true.")

  public Integer getTotalRecords() {
    return totalRecords;
  }


  public void setTotalRecords(Integer totalRecords) {
    this.totalRecords = totalRecords;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ResultSet resultSet = (ResultSet) o;
    return Objects.equals(this.count, resultSet.count) &&
        Objects.equals(this.limit, resultSet.limit) &&
        Objects.equals(this.more, resultSet.more) &&
        Objects.equals(this.nextOffset, resultSet.nextOffset) &&
        Objects.equals(this.offset, resultSet.offset) &&
        Objects.equals(this.totalRecords, resultSet.totalRecords);
  }

  @Override
  public int hashCode() {
    return Objects.hash(count, limit, more, nextOffset, offset, totalRecords);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ResultSet {\n");
    sb.append("    count: ").append(toIndentedString(count)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    more: ").append(toIndentedString(more)).append("\n");
    sb.append("    nextOffset: ").append(toIndentedString(nextOffset)).append("\n");
    sb.append("    offset: ").append(toIndentedString(offset)).append("\n");
    sb.append("    totalRecords: ").append(toIndentedString(totalRecords)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("count");
    openapiFields.add("limit");
    openapiFields.add("more");
    openapiFields.add("next_offset");
    openapiFields.add("offset");
    openapiFields.add("total_records");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ResultSet
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (ResultSet.openapiRequiredFields.isEmpty()) {
          return;
        } else { // has required fields
          throw new IllegalArgumentException(String.format("The required field(s) %s in ResultSet is not found in the empty JSON string", ResultSet.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ResultSet.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ResultSet` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ResultSet.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ResultSet' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ResultSet> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ResultSet.class));

       return (TypeAdapter<T>) new TypeAdapter<ResultSet>() {
           @Override
           public void write(JsonWriter out, ResultSet value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ResultSet read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ResultSet given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ResultSet
  * @throws IOException if the JSON string is invalid with respect to ResultSet
  */
  public static ResultSet fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ResultSet.class);
  }

 /**
  * Convert an instance of ResultSet to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

